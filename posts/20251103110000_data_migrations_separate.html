<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Schema and Data Migrations: Why They Should Be Separate</title>
    <meta name="description" content="Why schema migrations and data migrations are fundamentally different and should be managed separately, with best practices for implementing data migrations in Rails.">
    <meta name="keywords" content="rails, migrations, data migrations, schema migrations, active record, database, best practices">
    <meta name="author" content="Åndrei Makarov">
    <meta name="robots" content="index, follow">
    <meta property="og:title" content="Schema and Data Migrations: Why They Should Be Separate">
    <meta property="og:description" content="Why schema migrations and data migrations are fundamentally different and should be managed separately.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://amkisko.github.io/posts/20251103110000_data_migrations_separate.html">
    <meta property="article:published_time" content="2025-11-03T11:00:00+00:00">
    <meta property="article:modified_time" content="2025-11-03T11:00:00+00:00">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Schema and Data Migrations: Why They Should Be Separate">
    <meta name="twitter:description" content="Why schema migrations and data migrations are fundamentally different and should be managed separately.">
    <link rel="stylesheet" href="../styles/posts_text.css">
    <link rel="stylesheet" href="../styles/posts_navigation.css">
</head>
<body>
    <a href="../posts.html" id="map-link" title="Map"></a>
    <article>
        <h1>Schema and Data Migrations: Why They Should Be Separate</h1>
        <div class="date">3 November 2025, Helsinki, Åndrei Makarov</div>

        <p>Rails developers have been mixing schema and data migrations for years, and the results are predictably disastrous. The framework provides excellent tooling for structural changes—adding columns, creating tables, modifying indexes. But when developers use the same mechanism for data transformations, they create operational nightmares that compound over time.</p>

        <p>Vesa Vänskä's 2014 essay on <a href="http://vesavanska.com/2014/activerecord-migrations-best-practices">ActiveRecord migrations best practices</a> states plainly: "Migrations should not contain seed data." Yet teams continue to bundle data transformations into schema migrations, creating problems that surface during deployments, rollbacks, and database bootstrapping.</p>

        <h2>The False Equivalence</h2>

        <p>Schema migrations and data migrations appear similar—both modify the database, both use timestamped files, both run during deployment. This superficial similarity masks fundamental differences in purpose, execution requirements, and failure modes.</p>

        <p>Schema migrations change structure. They should be fast, automatic, and reversible. Data migrations transform content. They may take hours, require operator oversight, and often cannot be reversed. Mixing them creates a category error that manifests as deployment failures, incomplete databases, and impossible rollbacks.</p>

        <h2>The Bootstrap Problem</h2>

        <p>When you run <code>db:schema:load</code> to bootstrap a new database, Rails loads only the schema structure. Data migrations bundled into schema migrations never execute. Your database structure exists, but the data remains in its previous state. This breaks applications that assume data transformations have occurred.</p>

        <p>Teams discover this when staging environments behave differently than production, or when new developers struggle to set up local databases. The workaround—running all migrations sequentially—defeats the purpose of <code>schema.rb</code> as a snapshot of the current database state.</p>

        <h2>The Automation Trap</h2>

        <p>Most CI/CD pipelines automatically run <code>db:migrate</code> during deployment. This works for schema changes, which are fast and predictable. Data migrations, however, may require:</p>

        <ul>
            <li>Operator approval before execution</li>
            <li>Specific timing windows (e.g., during low-traffic periods)</li>
            <li>Manual verification of results</li>
            <li>Rollback plans if execution fails</li>
        </ul>

        <p>Automating data migrations removes human judgment from critical data transformations. A migration that updates millions of records should not run automatically at 2 AM during a deployment. Yet teams continue to mix data transformations into schema migrations, creating this exact scenario.</p>

        <h2>The Transaction Fallacy</h2>

        <p>Some developers wrap data migrations in transactions, assuming this provides safety. For large data transformations, transactions become memory-intensive and can cause database unresponsiveness. Wrapping a migration that updates ten million records in a transaction may exhaust available memory or lock tables for hours.</p>

        <p>Data migrations require batching, progress tracking, and the ability to pause and resume. These requirements conflict with the transaction model that works well for schema changes.</p>

        <h2>The Testing Paradox</h2>

        <p>Rails doesn't test schema migrations by default—they're considered framework-level operations. Data migrations inherit this pattern, but teams often want to test critical data transformations. Mixing schema and data migrations makes it unclear what requires testing and what doesn't.</p>

        <p>The <a href="https://github.com/amkisko/data-migration.rb">data-migration</a> gem provides in-file RSpec tests as an option, embedded directly in migration files. This acknowledges that data migrations may need testing while maintaining the Rails convention that migrations themselves aren't part of the main test suite.</p>

        <h2>Separation as Principle</h2>

        <p>Separating schema and data migrations isn't just organizational—it's a recognition that these operations serve different purposes and have different requirements:</p>

        <ul>
            <li><strong>Schema migrations:</strong> Fast, automatic, reversible, structural changes</li>
            <li><strong>Data migrations:</strong> Potentially slow, operator-controlled, often irreversible, content transformations</li>
        </ul>

        <p>The data-migration gem provides a framework that mimics ActiveRecord migrations but is designed for data transformations. It uses plain Ruby classes with a <code>perform</code> method, wraps them in ActiveJob for background execution, and tracks them via ActiveRecord models for auditing. This design follows familiar patterns while accommodating the unique requirements of data transformations.</p>

        <p>Data migrations should be planned beforehand, scheduled as release events, and executed with operator oversight. They may need batching, pause/resume capabilities, and progress tracking. These features don't belong in schema migrations, which must remain fast and automatic.</p>

        <h2>The Practical Alternative</h2>

        <p>Instead of mixing schema and data, separate them:</p>

        <p>Create a schema migration to add the column. Then create a separate data migration to populate it. Run the schema migration automatically during deployment. Run the data migration manually when appropriate, with operator oversight and monitoring.</p>

        <p>This separation provides control, visibility, and safety. Schema changes remain fast and automatic. Data transformations remain controlled and observable. Each operation uses the tooling appropriate to its requirements.</p>

        <h2>Conclusion</h2>

        <p>The temptation to mix schema and data migrations stems from convenience—one file, one execution, one commit. But this convenience creates operational debt that compounds over time. Deployment failures, incomplete databases, and impossible rollbacks are the inevitable results.</p>

        <p>Separating schema and data migrations requires discipline, but the benefits are immediate: better control over when data transformations execute, proper handling of database bootstrapping, and the ability to test and monitor data migrations independently. The data-migration gem provides the framework needed to implement this separation while maintaining familiar Rails patterns.</p>

        <p>As Vänskä noted over a decade ago, migrations should not contain seed data. The same principle applies to all data transformations. Structure and content are different concerns, and they deserve different tooling.</p>

        <div class="references">
            <h3>Related Articles</h3>
            <ul>
                <li><a href="20251104130000_seed_builder_organized_seeds.html">Organizing Seeds: From Single File to Structured Directory</a> - Another approach to managing Rails application data and initialization</li>
                <li><a href="20251111150825_activerecord_model_versioning.html">ActiveRecord Model Versioning: A Proposal for ActiveVersion</a> - Learn about versioning strategies for ActiveRecord models</li>
            </ul>

            <h3>References</h3>
            <ul>
                <li><a href="https://github.com/amkisko/data-migration.rb">data-migration gem on GitHub</a></li>
                <li><a href="http://vesavanska.com/2014/activerecord-migrations-best-practices">ActiveRecord Migrations Best Practices by Vesa Vänskä</a></li>
                <li><a href="https://guides.rubyonrails.org/active_record_migrations.html">Rails Active Record Migrations Guide</a></li>
            </ul>
        </div>
    </article>
    <a href="#" id="to-top" title="To the top"></a>

    <script src="../scripts/posts_navigation.js"></script>
</body>
</html>
